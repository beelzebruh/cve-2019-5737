/* 
 * ==========================================
 * File: c2.c
 * Author: Matthew Stacks & Brian Nelson
 * Organization: Rendition Infosec
 * Description: Modified PoC of CVE-2019-5736 for internal use by Rendition Infosec
 * 
 * Execution of this exploit occurs in three parts:
 * -- 1. Payload Stager (payloadstage.c)
 *     Responsible for: 
 *        Downloading (Staging) the Payload Setter
 *        Injecting the Payload Setter into Memory
 *        Passing Execution to the Payload Setter
 *        
 * -- 2. Payload Setter (payloadset.c)
 *    Responsible for:
 *         Establishing a Foothold
 *         Lateral Movement
 *         Enabling C2
 * 
 * -- 3. C2 (c2.c)
 *    Responsible for:
 *        Payload Execution
 *        Local Privilege Escalation
 *        Channel Establishment
 *        Data Exfiltration
 * 
 * ==========================================
 */

/* 
 * ==========================================
 * Header Files
 * 
 * stdio.h
 *     Defines standard I/O process streams:
 *         stdin
 *         stdout
 *         stderr
 *         null
 *     Defines these functions:
 *         printf()
 *         snprintf()
 *         get()
 *         set()
 *
 * sys/types.h
 *     Defines standard system data types:
 *         void
 *         char
 *         char *ptr
 *         int
 *     Defines __attribute__ ((constructor))
 *
 * sys/stat.h
 *     Defines the format of data returned by system calls 
 *         stat()
 *         lstat()
 *         fstat()
 *
 * fcntl.h
 *     Defines functions that act on File Descriptors:
 *         open()
 *         socket()  
 *         pipe()
 *         read()
 *         write()
 *     
 * unistd.h
 *     Provides access to the POSIX API
 *     Allows C compatibility between 
 *      POSIX, UNIX, macOS, and Linux
 *
 * ==========================================
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <netdb.h> 
#include <netinet/in.h> 
#include <stdlib.h> 
#include <string.h> 
#include <sys/socket.h> 
#include <sys/types.h> 
#define MAX 80 
#define PORT 8080 
#define SA struct sockaddr 

// Function designed for chat between client and server. 
void func(int sockfd) 
{ 
	char buff[MAX]; 
	int n; 
	// infinite loop for chat 
	for (;;) { 
		bzero(buff, MAX); 

		// read the message from client and copy it in buffer 
		read(sockfd, buff, sizeof(buff)); 
		// print buffer which contains the client contents 
		printf("From client: %s\t To client : ", buff); 
		bzero(buff, MAX); 
		n = 0; 
		// copy server message in the buffer 
		while ((buff[n++] = getchar()) != '\n') 
			; 

		// and send that buffer to client 
		write(sockfd, buff, sizeof(buff)); 

		// if msg contains "Exit" then server exit and chat ended. 
		if (strncmp("exit", buff, 4) == 0) { 
			printf("Server Exit...\n"); 
			break; 
		} 
	} 
} 

// Driver function 
int main() 
{ 
	int sockfd, connfd, len; 
	struct sockaddr_in servaddr, cli; 

	// socket create and verification 
	sockfd = socket(AF_INET, SOCK_STREAM, 0); 
	if (sockfd == -1) { 
		printf("socket creation failed...\n"); 
		exit(0); 
	} 
	else
		printf("Socket successfully created..\n"); 
	bzero(&servaddr, sizeof(servaddr)); 

	// assign IP, PORT 
	servaddr.sin_family = AF_INET; 
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY); 
	servaddr.sin_port = htons(PORT); 

	// Binding newly created socket to given IP and verification 
	if ((bind(sockfd, (SA*)&servaddr, sizeof(servaddr))) != 0) { 
		printf("socket bind failed...\n"); 
		exit(0); 
	} 
	else
		printf("Socket successfully binded..\n"); 

	// Now server is ready to listen and verification 
	if ((listen(sockfd, 5)) != 0) { 
		printf("Listen failed...\n"); 
		exit(0); 
	} 
	else
		printf("Server listening..\n"); 
	len = sizeof(cli); 

	// Accept the data packet from client and verification 
	connfd = accept(sockfd, (SA*)&cli, &len); 
	if (connfd < 0) { 
		printf("server acccept failed...\n"); 
		exit(0); 
	} 
	else
		printf("server acccept the client...\n"); 

	// Function for chatting between client and server 
	func(connfd); 

	// After chatting close the socket 
	close(sockfd); 
}
